---
title: "[스프링 핵심 원리 - 기본편] 섹션1. 객체 지향 설계와 스프링"
excerpt: "스프링 입문 - 김영한 님의 강의 내용입니다."
toc: true
toc_sticky: true
categories:
  - Spring
tags:
  - Backend
  - Java
  - 김영한
last_modified_at: 2021-07-19 21:11:20
---

# 섹션1. 객체 지향 설계와 스프링

<span style="color:grey">[스프링 핵심 원리 - 기본편] 내용입니다.</span>  

## 1.1. 이야기 - 자바 진영의 추운 겨울과 스프링의 탄생
  
옛날에 2000년 초, 자바 표준 기술이 EJB였음.  
EJB는 어렵고 복잡하고 느림. 그래서 개발자한테는 지옥이었음.  
  
이를 해결하고, ORM 기술을 사용할 수 있는 오픈 소스를 만들고자하여 탄생한 것이 **Spring!**  
Spring의 뜻이 추운 겨울이 끝나고 찾아온 봄이라고 하더라..  
  
Sping을 통해 이전보다 훨씬 편한 개발 환경이 되었지만,  
Spring도 문제가 있었음. 그것은 바로 <u>초기 셋팅</u>
  
<u>"스프링 개발은 설정이 절반이다."</u> 라는 말이 있을 정도..
  
그래서 등장한게 2014년에 등장한 **Spring Boot** 임  
  
> Spring Boot?  
> 스프링을 편리하게 사용할 수 있도록 지원, 최근에는 기본으로 사용하는 편  
> 단독으로 사용할 수 없고, 스프링 프레임워크를 사용하는 환경에서 사용되어 도와주는 역할  
  
## 1.2. 스프링이란?
  
[Spring Documentation](https://spring.io/projects)
  
### Spring의 필수요소, 선택요소
  
- 필수 요소
  - 스프링 프레임 워크
  - 스프링 부트  
  
- 선택 요소
  - 스프링 데이터
  - 스프링 세션
  - 스프링 시큐리티
  - 스프링 Rest Docs
  - 스프링 배치
  - 스프링 클라우드
  
### 스프링을 만든 이유
  
Spring은 `Java` 기반의 프레임워크이며, 자바의 가장 큰 특징은 <u>'객체 지향 언어'</u> 라는 점이다.  
이러한 객체 지향 언어가 가진 강력한 특징을 살려내는 프레임워크가 바로 **Spring**  
  
즉, 스프링은 좋은 객체 지향 애플리케이션을 개발할 수 있게 도와주는 프레임워크.
  
## 1.3. 좋은 객체 지향 프로그래밍이란?
  
적절한 역할과 구현의 분리를 통해 프로그램을 유연하고 변경에 용이하게 만드는 것  
  
### 객체 지향의 특징
- 추상화
- 캡슐화
- 상속
- 다형성 (Polymorphism : 객체 지향의 핵심)
  
### 역할과 구현의 분리
  
다형성의 원리를 활용하면 된다!
  
- 역할 : 인터페이스  
- 구현 : 인터페이스를 구현한 클래스 혹은 객체  
  
**다형성을 통해,**
클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경하여 분리한다  
- '클라이언트'는 대상의 역할(인터페이스)만 알면 된다.
- '클라이언트'는 구현 대상의 '내부 구조를 몰라도' 된다.
- '클라이언트'는 구현 대상의 '내부 구조가 변경'되어도 영향을 받지 않는다.
- '클라이언트'는 구현 '대상 자체를 변경'해도 영향을 받지 않는다.
  
## 1.4. 좋은 객체 지향의 5가지 원칙(SOLID)
  
- SRP: 단일 책임 원칙(single responsibility principle) 
  - `하나의 클래스는 하나의 책임만 가져야 한다.`
  - 변경이 있을 때 파급 효과가 적어야 한다.
  
- OCP: 개방-폐쇄 원칙 (Open/closed principle)
  - 소프트웨어 요소는 `확장에서는 열려 있으나 변경에는 닫혀 있어야 한다.`
  - 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현.
  
- LSP: 리스코프 치환 원칙 (Liskov substitution principle)
  - 프로그램의 `객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.`
  - 다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다.
  
- ISP: 인터페이스 분리 원칙 (Interface segregation principle)
  - `특정 클라이언트를 위한 인터페이스 여러 개`가 범용 인터페이스 하나보다 낫다.
  - 인터페이스의 분리로 인터페이스가 명확해지고, 대체 가능성이 높아진다.
  
- DIP: 의존관계 역전 원칙 (Dependency inversion principle)
  - 프로그래머는 `“추상화에 의존해야지, 구체화에 의존하면 안된다.”`
  - 의존성 주입은 이 원칙을 따르는 방법 중 하나
  - 구현 클래스에 의존하지 말고, `인터페이스`에 의존하라
  - `역할(Interface)`에 의존해야 구현의 변경에 유연해질 수 있다
  
## 1.5. 객체 지향 설계와 스프링
  
### 다형성의 한계
다형성만으로는 위의 5가지 원칙에 있어서 2가지 원칙이 위반된다.
- OCP 위반
  - 구현 객체를 변경하려면 클라이언트 코드를 변경이 불가피하다.
  ``` java

  public class MemberService {
    // 기존 코드
    private MemberRepository memberRepository = new MemoryMemberRepository();
    }
    // 변경 코드
    public class MemberService {
      //private MemberRepository memberRepository = new MemoryMemberRepository();
      private MemberRepository memberRepository = new JdbcMemberRepository();
    }
  ```
  - 이를 위해선 `객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다.`
  
- DIP 위반
  - MemberService는 인터페이스(추상화)에 의존하지만, 구현 클래스(구체화)도 동시에 의존한다.
  - 즉, 추상화, 구체화 둘다 의존하게 된다.
  
### 스프링이 필요한 이유?
  
스프링은 다음 기술로 다형성 + OCP, DIP를 가능하게 지원한다.  
- DI (Dependency Injection) : 의존관계, 의존성 주입
- DI 컨테이너 제공
  
### 정리
- 모든 설계에 역할과 구현을 분리하자.  
- 자동차, 공연의 예를 떠올려보자.  
- 애플리케이션 설계도 공연을 설계 하듯이 배역만 만들어두고, 배우는 언제든지 유연하게 변경할 수 있도록 만드는 것이 좋은 객체 지향 설계다.  
- 이상적으로는 모든 설계에 인터페이스를 부여하자.  
  
- 하지만 인터페이스를 도입하면 추상화라는 비용이 발생한다.
- 기능을 확장할 가능성이 없다면, 구체 클래스를 직접 사용하고 
- 향후 꼭 필요할 때 리팩터링해서 인터페이스를 도입하는 것도 방법이다.
  
끝-!😋